// src/core/finance/gateway/gateway.service.ts

/**
 * Town-in-a-Box Finance Engine - Gateway Export Service
 *
 * Pure functions for converting internal report data to Gateway-style
 * export formats. These functions handle the transformation from our
 * internal report structures to state-compliant export formats.
 *
 * Design Principles:
 * - Pure functions: no side effects, no database calls
 * - Takes report data in, produces export data out
 * - State-agnostic at this level (state-specific logic in state packs)
 */

import {
  SimplifiedTrialBalanceReport,
  SimplifiedTrialBalanceFundRow,
} from '../reports';
import {
  GatewayFundSummaryExport,
  GatewayFundSummaryRow,
  GatewayExportContext,
  GatewayExportMetadata,
  GatewayValidationResult,
  GatewayValidationMessage,
} from './gateway.types';

// ============================================================================
// FUND SUMMARY EXPORT
// ============================================================================

/**
 * Build a Gateway Fund Summary Export from a Trial Balance Report.
 *
 * This function transforms our internal trial balance data into the
 * Gateway-friendly export format suitable for AFR submission.
 *
 * @param context - Export context with tenant identity and date info
 * @param trialBalance - A trial balance report generated by buildTrialBalanceReport
 * @returns GatewayFundSummaryExport ready for submission
 *
 * @example
 * ```typescript
 * const trialBalance = buildTrialBalanceReport(funds, transactions, asOfDate);
 * const context: GatewayExportContext = {
 *   tenantIdentity: { ... },
 *   asOf: new Date('2024-12-31'),
 * };
 * const export = buildGatewayFundSummaryExport(context, trialBalance);
 * ```
 */
export function buildGatewayFundSummaryExport(
  context: GatewayExportContext,
  trialBalance: SimplifiedTrialBalanceReport
): GatewayFundSummaryExport {
  // Transform trial balance rows to Gateway format
  const rows: GatewayFundSummaryRow[] = trialBalance.rows.map(
    (row: SimplifiedTrialBalanceFundRow) => ({
      fundCode: row.fundCode,
      fundName: row.fundName,
      beginningBalance: row.beginningBalance,
      totalReceipts: row.totalReceipts,
      totalDisbursements: row.totalDisbursements,
      endingBalance: row.endingBalance,
    })
  );

  return {
    context,
    rows,
    totalBeginningBalance: trialBalance.totalBeginningBalance,
    totalReceipts: trialBalance.totalReceipts,
    totalDisbursements: trialBalance.totalDisbursements,
    totalEndingBalance: trialBalance.totalEndingBalance,
  };
}

// ============================================================================
// VALIDATION
// ============================================================================

/**
 * Validate a Gateway Fund Summary Export.
 *
 * Performs basic validation checks to ensure the export data is
 * consistent and suitable for submission. State-specific validation
 * rules should be implemented in state packs.
 *
 * @param exportData - The export data to validate
 * @returns Validation result with errors, warnings, and info messages
 */
export function validateGatewayFundSummaryExport(
  exportData: GatewayFundSummaryExport
): GatewayValidationResult {
  const errors: GatewayValidationMessage[] = [];
  const warnings: GatewayValidationMessage[] = [];
  const info: GatewayValidationMessage[] = [];

  // Check for required context
  if (!exportData.context.tenantIdentity?.tenantId) {
    errors.push({
      code: 'MISSING_TENANT_ID',
      message: 'Tenant ID is required for Gateway exports',
      field: 'context.tenantIdentity.tenantId',
    });
  }

  if (!exportData.context.asOf) {
    errors.push({
      code: 'MISSING_AS_OF_DATE',
      message: 'As-of date is required for Gateway exports',
      field: 'context.asOf',
    });
  }

  // Check for empty export
  if (exportData.rows.length === 0) {
    warnings.push({
      code: 'NO_FUNDS',
      message: 'Export contains no fund data',
    });
  }

  // Validate mathematical consistency
  const calculatedTotal = exportData.rows.reduce(
    (sum, row) => sum + row.endingBalance,
    0
  );
  const reportedTotal = exportData.totalEndingBalance;
  const tolerance = 0.01; // Allow for floating point rounding

  if (Math.abs(calculatedTotal - reportedTotal) > tolerance) {
    errors.push({
      code: 'TOTAL_MISMATCH',
      message: `Calculated ending balance (${calculatedTotal.toFixed(2)}) does not match reported total (${reportedTotal.toFixed(2)})`,
      field: 'totalEndingBalance',
    });
  }

  // Validate each fund row
  for (const row of exportData.rows) {
    // Check balance calculation
    const expectedEnding = row.beginningBalance + row.totalReceipts - row.totalDisbursements;
    if (Math.abs(row.endingBalance - expectedEnding) > tolerance) {
      errors.push({
        code: 'FUND_BALANCE_MISMATCH',
        message: `Fund ${row.fundCode}: Ending balance does not match calculation`,
        fundCode: row.fundCode,
      });
    }

    // Check for negative ending balance (warning, not error)
    if (row.endingBalance < 0) {
      warnings.push({
        code: 'NEGATIVE_BALANCE',
        message: `Fund ${row.fundCode} (${row.fundName}) has a negative ending balance`,
        fundCode: row.fundCode,
      });
    }

    // Check for missing fund code
    if (!row.fundCode) {
      errors.push({
        code: 'MISSING_FUND_CODE',
        message: 'Fund code is required',
        field: 'fundCode',
      });
    }
  }

  // Add info about export
  info.push({
    code: 'EXPORT_SUMMARY',
    message: `Export contains ${exportData.rows.length} funds with total ending balance of ${exportData.totalEndingBalance.toFixed(2)}`,
  });

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    info,
  };
}

// ============================================================================
// METADATA GENERATION
// ============================================================================

/**
 * Generate export metadata for tracking and auditing.
 *
 * @param exportData - The export data
 * @param generatedBy - Who/what generated the export
 * @returns Export metadata
 */
export function generateExportMetadata(
  exportData: GatewayFundSummaryExport,
  generatedBy?: string
): GatewayExportMetadata {
  const fiscalYear = exportData.context.fiscalYear ??
    exportData.context.asOf.getFullYear();

  return {
    exportId: `GW-${fiscalYear}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    exportType: 'FUND_SUMMARY',
    generatedAt: new Date(),
    generatedBy,
    tenantId: exportData.context.tenantIdentity.tenantId,
    stateCode: exportData.context.tenantIdentity.state,
    fiscalYear,
    format: 'JSON',
  };
}

// ============================================================================
// EXPORT FORMATTERS
// ============================================================================

/**
 * Convert Gateway Fund Summary Export to CSV format.
 *
 * @param exportData - The export data
 * @returns CSV string
 */
export function exportFundSummaryToCSV(
  exportData: GatewayFundSummaryExport
): string {
  const headers = [
    'Fund Code',
    'Fund Name',
    'Beginning Balance',
    'Total Receipts',
    'Total Disbursements',
    'Ending Balance',
  ];

  const lines: string[] = [];

  // Header comment
  lines.push(`# Gateway Fund Summary Export`);
  lines.push(`# Tenant: ${exportData.context.tenantIdentity.displayName}`);
  lines.push(`# As Of: ${exportData.context.asOf.toISOString().split('T')[0]}`);
  lines.push(`# Generated: ${new Date().toISOString()}`);
  lines.push('');

  // Column headers
  lines.push(headers.join(','));

  // Data rows
  for (const row of exportData.rows) {
    const values = [
      `"${row.fundCode}"`,
      `"${row.fundName}"`,
      row.beginningBalance.toFixed(2),
      row.totalReceipts.toFixed(2),
      row.totalDisbursements.toFixed(2),
      row.endingBalance.toFixed(2),
    ];
    lines.push(values.join(','));
  }

  // Totals row
  lines.push('');
  lines.push(
    [
      '"TOTALS"',
      '""',
      exportData.totalBeginningBalance.toFixed(2),
      exportData.totalReceipts.toFixed(2),
      exportData.totalDisbursements.toFixed(2),
      exportData.totalEndingBalance.toFixed(2),
    ].join(',')
  );

  return lines.join('\n');
}

/**
 * Sort Gateway Fund Summary rows by fund code.
 *
 * Sorts funds in SBOA standard order (numeric fund codes first,
 * then alphabetic).
 *
 * @param rows - The rows to sort
 * @returns Sorted rows (new array)
 */
export function sortGatewayFundSummaryRows(
  rows: GatewayFundSummaryRow[]
): GatewayFundSummaryRow[] {
  return [...rows].sort((a, b) => {
    const codeA = parseInt(a.fundCode, 10);
    const codeB = parseInt(b.fundCode, 10);

    // Both numeric - sort numerically
    if (!isNaN(codeA) && !isNaN(codeB)) {
      return codeA - codeB;
    }

    // One numeric, one not - numeric first
    if (!isNaN(codeA)) return -1;
    if (!isNaN(codeB)) return 1;

    // Both non-numeric - sort alphabetically
    return a.fundCode.localeCompare(b.fundCode);
  });
}
